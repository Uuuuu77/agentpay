import type { FileStorageService } from "./file-storage"
import type { Invoice } from "../../types"
import { generateCode, generateCreativeContent } from "../../lib/ai-services"

interface ScriptServiceRequest {
  invoice: Invoice
  description: string
  options: {
    runtime?: "Python" | "Node.js" | "Bash"
    complexity?: "Simple" | "Medium" | "Complex"
  }
  buyerContact?: string
}

export class ScriptService {
  private fileStorage: FileStorageService

  constructor(fileStorage: FileStorageService) {
    this.fileStorage = fileStorage
  }

  async process(request: ScriptServiceRequest): Promise<string> {
    const { description, options } = request
    const runtime = options.runtime || "Python"

    console.log(`Generating ${runtime} script for: ${description}`)

    try {
      const scriptContent = await this.generateScript(description, runtime)
      const documentation = await this.generateDocumentation(description, runtime)
      const requirements = await this.generateRequirements(runtime)
      const examples = await this.generateExamples(description, runtime)

      const files = [
        {
          filename: this.getScriptFilename(runtime),
          content: scriptContent,
        },
        {
          filename: "README.md",
          content: documentation,
        },
        {
          filename: this.getRequirementsFilename(runtime),
          content: requirements,
        },
        {
          filename: "examples.md",
          content: examples,
        },
      ]

      return await this.fileStorage.saveMultipleFiles(files)
    } catch (error) {
      console.error("Script service error:", error)
      throw new Error("Failed to generate automation script")
    }
  }

  private async generateScript(description: string, runtime: string): Promise<string> {
    const prompt = `Generate a professional ${runtime} automation script for: ${description}

Requirements:
- Production-ready code with proper error handling
- Configurable via environment variables
- Comprehensive logging and debugging
- Modular, maintainable structure
- Include proper documentation strings
- Follow ${runtime} best practices

The script should be robust, well-structured, and ready for immediate use.`

    try {
      const aiGeneratedCode = await generateCode(prompt, runtime.toLowerCase())

      // If AI generation fails, fall back to template-based generation
      if (!aiGeneratedCode || aiGeneratedCode.length < 100) {
        return this.generateTemplateScript(description, runtime)
      }

      return aiGeneratedCode
    } catch (error) {
      console.error("AI code generation failed, using template:", error)
      return this.generateTemplateScript(description, runtime)
    }
  }

  private generateTemplateScript(description: string, runtime: string): string {
    switch (runtime) {
      case "Python":
        return this.generatePythonScript(description)
      case "Node.js":
        return this.generateNodeScript(description)
      case "Bash":
        return this.generateBashScript(description)
      default:
        return this.generatePythonScript(description)
    }
  }

  private generatePythonScript(description: string): string {
    return `#!/usr/bin/env python3
"""
Automation Script: ${description}
Generated by AgentPay
"""

import os
import sys
import json
import requests
from datetime import datetime


class AutomationScript:
    def __init__(self):
        self.config = self.load_config()
    
    def load_config(self):
        """Load configuration from environment or config file"""
        return {
            'api_key': os.getenv('API_KEY', ''),
            'output_dir': os.getenv('OUTPUT_DIR', './output'),
            'debug': os.getenv('DEBUG', 'false').lower() == 'true'
        }
    
    def run(self):
        """Main execution function"""
        print(f"Starting automation: {description}")
        
        try:
            # Main automation logic here
            result = self.process_data()
            self.save_results(result)
            
            print("Automation completed successfully!")
            return result
            
        except Exception as e:
            print(f"Error: {e}")
            sys.exit(1)
    
    def process_data(self):
        """Process the main automation task"""
        # Implement your automation logic here
        return {
            'status': 'completed',
            'timestamp': datetime.now().isoformat(),
            'description': '${description}'
        }
    
    def save_results(self, result):
        """Save results to output directory"""
        os.makedirs(self.config['output_dir'], exist_ok=True)
        
        output_file = os.path.join(
            self.config['output_dir'], 
            f'result_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
        )
        
        with open(output_file, 'w') as f:
            json.dump(result, f, indent=2)
        
        print(f"Results saved to: {output_file}")


if __name__ == "__main__":
    script = AutomationScript()
    script.run()
  }

  private generateNodeScript(description: string): string {
    return \`#!/usr/bin/env node
/**
 * Automation Script: ${description}
 * Generated by AgentPay
 */

const fs = require('fs').promises;
const path = require('path');
const axios = require('axios');

class AutomationScript {
    constructor() {
        this.config = this.loadConfig();
    }

    loadConfig() {
        return {
            apiKey: process.env.API_KEY || '',
            outputDir: process.env.OUTPUT_DIR || './output',
            debug: process.env.DEBUG === 'true'
        };
    }

    async run() {
        console.log('Starting automation: ${description}');
        
        try {
            const result = await this.processData();
            await this.saveResults(result);
            
            console.log('Automation completed successfully!');
            return result;
            
        } catch (error) {
            console.error('Error:', error.message);
            process.exit(1);
        }
    }

    async processData() {
        // Implement your automation logic here
        return {
            status: 'completed',
            timestamp: new Date().toISOString(),
            description: '${description}'
        };
    }

    async saveResults(result) {
        await fs.mkdir(this.config.outputDir, { recursive: true });
        
        const outputFile = path.join(
            this.config.outputDir,
            \`result_\${new Date().toISOString().replace(/[:.]/g, '-')}.json\`
        );
        
        await fs.writeFile(outputFile, JSON.stringify(result, null, 2));
        console.log(\`Results saved to: \${outputFile}\`);
    }
}

// Run the script
if (require.main === module) {
    const script = new AutomationScript();
    script.run().catch(console.error);
}

module.exports = AutomationScript;
  }

  private generateBashScript(description: string): string {
    return \`#!/bin/bash
# Automation Script: ${description}
# Generated by AgentPay

set -e  # Exit on any error

# Configuration
API_KEY=\${API_KEY:-""}
OUTPUT_DIR=\${OUTPUT_DIR:-"./output"}
DEBUG=\${DEBUG:-"false"}

# Create output directory
mkdir -p "$OUTPUT_DIR"

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Main automation function
run_automation() {
    log "Starting automation: ${description}"
    
    # Main automation logic here
    local result_file="$OUTPUT_DIR/result_$(date '+%Y%m%d_%H%M%S').txt"
    
    # Example automation task
    echo "Automation completed successfully" > "$result_file"
    echo "Description: ${description}" >> "$result_file"
    echo "Timestamp: $(date)" >> "$result_file"
    
    log "Results saved to: $result_file"
    log "Automation completed successfully!"
}

# Error handling
handle_error() {
    log "Error occurred on line $1"
    exit 1
}

trap 'handle_error $LINENO' ERR

# Run the automation
run_automation
`
  }

  private async generateDocumentation(description: string, runtime: string): Promise<string> {
    const prompt = `Create comprehensive documentation for a ${runtime} automation script that: ${description}

Include:
- Clear description and purpose
- Installation instructions
- Usage examples
- Configuration options
- Troubleshooting guide
- Best practices

Format as professional README.md with proper markdown structure.`

    try {
      const aiDoc = await generateCreativeContent(prompt, "technical documentation")
      if (aiDoc && aiDoc.length > 200) {
        return aiDoc
      }
    } catch (error) {
      console.error("AI documentation generation failed:", error)
    }

    // Fallback to template documentation
    return `# Automation Script

## Description
${description}

## Runtime
${runtime}

## Installation

### ${runtime === "Python" ? "Python Requirements" : runtime === "Node.js" ? "Node.js Requirements" : "System Requirements"}
${this.getInstallationInstructions(runtime)}

## Usage

### Basic Usage
\`\`\`bash
${this.getUsageCommand(runtime)}
\`\`\`

### Configuration
Set the following environment variables:

- \`API_KEY\`: Your API key (if required)
- \`OUTPUT_DIR\`: Directory for output files (default: ./output)
- \`DEBUG\`: Enable debug mode (true/false)

### Example
\`\`\`bash
export API_KEY="your-api-key"
export OUTPUT_DIR="./results"
${this.getUsageCommand(runtime)}
\`\`\`

## Output
The script will create output files in the specified directory with timestamps.

## Error Handling
The script includes comprehensive error handling and logging.

## Support
For questions or issues, contact support through the AgentPay platform.

Generated: ${new Date().toLocaleString()}
`
  }

  private async generateRequirements(runtime: string): Promise<string> {
    switch (runtime) {
      case "Python":
        return `requests>=2.28.0
python-dotenv>=0.19.0
`
      case "Node.js":
        return `{
  "name": "automation-script",
  "version": "1.0.0",
  "dependencies": {
    "axios": "^1.6.0",
    "dotenv": "^16.3.0"
  }
}
`
      case "Bash":
        return `# System Requirements
- bash 4.0+
- curl
- jq (for JSON processing)

# Installation on Ubuntu/Debian:
sudo apt-get update
sudo apt-get install curl jq

# Installation on macOS:
brew install jq
`
      default:
        return ""
    }
  }

  private async generateExamples(description: string, runtime: string): Promise<string> {
    return `# Usage Examples

## Basic Example
${this.getBasicExample(runtime)}

## Advanced Example
${this.getAdvancedExample(runtime)}

## Troubleshooting

### Common Issues
1. **Permission denied**: Make sure the script is executable
   \`\`\`bash
   chmod +x ${this.getScriptFilename(runtime)}
   \`\`\`

2. **Missing dependencies**: Install required packages
   ${this.getInstallationInstructions(runtime)}

3. **API errors**: Check your API key and network connection

### Debug Mode
Enable debug mode for detailed logging:
\`\`\`bash
export DEBUG=true
${this.getUsageCommand(runtime)}
\`\`\`

Generated: ${new Date().toLocaleString()}
`
  }

  private getScriptFilename(runtime: string): string {
    switch (runtime) {
      case "Python":
        return "automation.py"
      case "Node.js":
        return "automation.js"
      case "Bash":
        return "automation.sh"
      default:
        return "script.txt"
    }
  }

  private getRequirementsFilename(runtime: string): string {
    switch (runtime) {
      case "Python":
        return "requirements.txt"
      case "Node.js":
        return "package.json"
      case "Bash":
        return "INSTALL.md"
      default:
        return "requirements.txt"
    }
  }

  private getUsageCommand(runtime: string): string {
    switch (runtime) {
      case "Python":
        return "python automation.py"
      case "Node.js":
        return "node automation.js"
      case "Bash":
        return "./automation.sh"
      default:
        return "python script.py"
    }
  }

  private getInstallationInstructions(runtime: string): string {
    switch (runtime) {
      case "Python":
        return "pip install -r requirements.txt"
      case "Node.js":
        return "npm install"
      case "Bash":
        return "See INSTALL.md for system requirements"
      default:
        return ""
    }
  }

  private getBasicExample(runtime: string): string {
    return `\`\`\`bash
${this.getUsageCommand(runtime)}
\`\`\``
  }

  private getAdvancedExample(runtime: string): string {
    return `\`\`\`bash
export API_KEY="your-key"
export OUTPUT_DIR="./custom-output"
export DEBUG=true
${this.getUsageCommand(runtime)}
\`\`\``
  }
}
